\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage[margin=3cm]{geometry}


% German
%\usepackage[ngerman]{babel}
% English
\usepackage[english]{babel}

\usepackage[round,authoryear]{natbib}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[hyphens]{url}
\usepackage{caption} 
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{lipsum}

\graphicspath{ {./images} }
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
}


% German
%\newtheorem{definition}{Definition}
%\newtheorem{satz}{Satz}
% English
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}

% TODO
\author{Alexander Lutsch\\Ephraim Siegfried\\Felix Andrist}
\title{ \Huge Cuisinventory }
\date{Fall Semester, 2023 \\ Computer Architecture}


\begin{document}
\maketitle

\section{Cuisinventory Introduction}
Cuisinventory is a grocery inventory managament system offering an easy way to keep track of consumption and additional product information.
It comes in the form of a station which has a barcode scanner and a weight scale with which you can interact. You can scan your groceries' barcode at the Cuisinventory station and
it will automatically fetch related product information like name, brands, allergens and conservation conditions. Additionally you will be able to weigh the groceries and with the fetched information about product quantity,
Cuisinventory will be able to provide percentage information about how much food is left for consumption. All of the inventory information is saved locally in a custom developed database, you can view it on a web application with which the station communicates.

\section{Materials and Software}
\subsection{Hardware}
The following table lists the hardware used to implement the project.
\\[10pt]
\begin{tabular}{l l}
	\hline
	Component              & Model\\
	\hline
	Main Controller        & Adafruit Feather nRF52840\\
	Barcode-Code Scanner   & SparkFun 2D Barcode Scanner Breakout\\
	Strain Gauge Load Cell & Strain Gauge Load Cell - 4 Wires - 5Kg\\
	ADC-Chip               & Adafruit NAU7802 24-Bit ADC - STEMMA QT / Qwiic\\
	Display                & SparkFun LCD-16398\\
	WLAN Co-Processor      & Adafruit AirLift FeatherWing ESP32\\
	I2C Interface          & SparkFun Qwiic / Stemma QT FeatherWing\\
	3 * Buttons            & SparkFun Zubeh√∂r Qwiic Button - Green LED\\
	Cable                  & SparkFun Qwiic Cable Kit\\
	Adalogger              & Adalogger FeatherWing - RTC + SD Add-on\\
	Stacking Headers       & Adafruit 12-pin and 16-pin female headers\\
	\hline
\end{tabular} \\[10pt]
Fundamentally we have the main controller, the Adafruit Feather nRF52840, offering a 64MHz ARM Cortex M4F processor along with 256KB of SRAM.
It supports Arduino libraries and has a wide array of external ports to which we can connect the other components.
We expand the capabilties of our main controller with a WLAN Chip and a SD card.
For the interaction with the controller we use 3 main buttons, a strain gauge load cell which measures weight, and a barcode scanner.
A small LCD display outputs information. 
\subsection{Required Libraries}
Conveniently, every required hardware component offered at least one library we could use for the software implementation. 
Below is a table showing the hardware components and a github link to the corresponding libraries we decided for.
\\[10pt]
\begin{tabular}{l l}
	\hline
	Component              & Library\\
	\hline
	Barcode-Scanner        & \href{https://github.com/sparkfun/SparkFun_DE2120_Arduino_Library}{SparkFun DE2120 Arduino Library}\\
	Load Cell \& ADC-Chip  & \href{https://github.com/adafruit/Adafruit_NAU7802}{Adafruit NAU7802}\\
	Display                & \href{https://github.com/sparkfun/SparkFun_SerLCD_Arduino_Library}{SparkFun SerLCD Arduino Library}\\
	WLAN Co-Processor      & \href{https://github.com/adafruit/WiFiNINA}{WiFiNINA Adafruit Fork}\\
	Buttons                & \href{https://github.com/sparkfun/SparkFun_Qwiic_Button_Arduino_Library}{SparkFun Qwiic Button Arduino Library}\\
	Adalogger              & \href{https://github.com/adafruit/SdFat}{SdFat Adafruit Fork}\\
	\hline
\end{tabular} \\[10pt]
Additionally we also rely on the SPI, Wire and SoftwareSerial libraries which are included in the Arduino Core and enable communication protocols for the provided pins of our main controller. \\
On the software side we use the \href{https://github.com/arduino-libraries/ArduinoHttpClient}{Arduino HTTP Client} to help us structure the sending and receiving of HTTP requests.
One of the most important libraries for this project is the \href{https://github.com/bblanchon/ArduinoJson}{Arduino Json Library} with which we can correctly serialize and deserialize JSON Files on our local controller and SD card.
Our database logic fundamentally relies on saving and retrieving information in the JSON format. \\
\subsection{Software Development}
We used git version control with github to collaborate on the code.
As we weren't happy with the limitations of the Arduino IDE we switched our IDE to PlatformIO.
PlatformIO enabled us a more professional approach. We can define different environments for our compilation and also have automatic library management over a central config file.
With this we can code using external editors and don't have to worry about naming limitations like .ino or different local library versions. Additionally we could implement unit tests for our important classes.
With github and platformio we were able to set up a continuous integration system, we set up github actions to format the codestyle and run a compile of the code.
The remote execution function of platformio enabled us to run unit tests on the controller over another github action.

\section{User Manual}
\lipsum[1]\lipsum[1]
\section{Implementation}
\subsection{Hardware}
\subsubsection{Putting the sensors together}
With a lot of hardware components for this project we had to make sure that we can connect all of them to the microcontroller.
We started with the SD Card extension (Adalogger) and the Wlan Co-Processor. Both of them are small boards about as big as the microcontroller, so using stacking headers we stacked both of them on top of the main controller.\\
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{cat.jpg}
    \caption{Stacking Wifi and SD Card}
    \label{fig:mesh1}
\end{figure}\\
Now whats left is the strain load cell along with the adc chip for weight measurement, the LCD display, the three buttons and the barcode scanner. 
Everything apart from the barcode scanner uses the I2C protocol for communication. This is convenient as I2C supports multiple devices on the same BUS.
We connected the three Buttons, the ADC weight chip and the LCD display over I2C to the same BUS. Additionally we used the SparkFun Qwiic I2C connectors which enable just plugging cables with
connectors together in daisy chain requiring less soldering. The QWIIC connectors required a SparkFun Qwiic Shield board to which we connect the I2C pins and which we again stacked on top of the other boards.\\
This leaves the Barcode Scanner which communicates over UART and still has place on the so far unused RX and TX pins.
With everything connected we just have to check that there is no overlap in the I2C addresses of the devices which are connected to our single I2C Bus.
In our case we had to manually change the I2C addresses of the three buttons over the button software library.
\subsubsection{Designing the case}
As we are building a kitchen station with a weight sensor, we have the need for a case.
Write more here.
\subsection{Software}
The Cuisinventory station fundamentally has three functions which are offered to the user: Adding a product, updating the weight of a product and removing a product.
These three functions are coded in the main logic with calls to secondary classes which contain the implementation for necessary hardware and software components.
Additionally the main logic contains the necessary initializations for the hardware components. 
\subsubsection{Buttons}
For the Buttons we rely on the \href{https://github.com/sparkfun/SparkFun_Qwiic_Button_Arduino_Library}{SparkFun Qwiic Button Arduino Library} with which we can read out the buffer of presses which is saved on the button itself.
In the file Input.cpp we have logic for reading out the input of a desired button which filters out input from the buffer which is too old.
Additionally we can also differentiate between a long and a short press of the button.
\subsubsection{LCD Display}
The LCD uses the \href{https://github.com/sparkfun/SparkFun_SerLCD_Arduino_Library}{SparkFun SerLCD Arduino Library} and is quite straightforward to use. It doesn't have its own cpp file but is just initialized in the main logic
and then called in the three main functions to display info to the user.
\subsubsection{Weightsensor}
The weightsensor consists of two parts, the strain load cell which sends electrical output based on the strain its put on and the analog to digital converter (ADC chip) which interprets this output into a digital value.
For the ADC chip we rely on the \href{https://github.com/adafruit/Adafruit_NAU7802}{Adafruit NAU7802}\\ library to read out digital measurements.
These measurements then have to be converted to grams by multiplication with a factor which we have to find by calibrating the sensor with different weights.
The ADC chip has its own Scale.cpp file in which we handle initialization and calibrating the offset at the start to zero.
\subsubsection{Barcode Scanner}
The barcode scanner is the only sensor connected over UART. It contains an internal buffer with successfully read barcodes.
We use the \href{https://github.com/sparkfun/SparkFun_DE2120_Arduino_Library}{SparkFun DE2120 Arduino Library} to interact with the scanner.
The usage is pretty straightforward, we basically have to initialize the sensor and we can then read out the internal buffer.
The implemenation is found in the BarReader.cpp file.
\subsubsection{WLAN Co-Processor and the WifiService Class}
For the WLAN Co-Processor we rely on the \href{https://github.com/adafruit/WiFiNINA}{WiFiNINA Adafruit Fork} library.
The logic concerning the WLAN initialization and internet communciation is found in the WiFiService.cpp file.
When initializing we try to connect to a WIFI network using the SSID and password which is found on a json file saved on the SD card.
After the user scans a barcode we have to fetch information from an external barcode database, in our case the barcode API from https://world.openfoodfacts.org/ is free and offers an excellent amount of information about a wide range of products.
The WIFIService class handles sending a http request to the API with the help of \href{https://github.com/arduino-libraries/ArduinoHttpClient}{Arduino HTTP Client}.
The response will be a JSON containing the information which is processed with the \href{https://github.com/bblanchon/ArduinoJson}{Arduino Json Library}.
Additionally to receiving information we also need to send information to our own webserver which displays the full inventory, for this the WIFIService class contains a method which sends a JSON File to the server. 
\subsubsection{SD card and the Database class}
We have a micro SD card in our "Adalogger" module on which we want to save our inventory information.
For writing and reading from the SD card we work with the \href{https://github.com/adafruit/SdFat}{SdFat Adafruit Fork} library.
The logic of the database is found in the DBClass, DB.cpp file. Fundamentally we want to save all relevant information about the products in the inventory in JSON Files on the SD card.
The DBClass provides methods for saving and retrieving information, it relies heavily on the \href{https://github.com/bblanchon/ArduinoJson}{Arduino Json Library} with which we serialize and deserialize JSON files.
As we have to work with the limited amount of RAM of a microchip we can't just put the entire inventory in a single JSON file.
Instead, every product in the inventory has its own JSON File and we generate unique IDs to differentiate them. We have to do this as our inventory can contain multiple products with the same barcode.
These unique IDs are written into the json file of the product and the json file itself has the unique ID as filename when saved on the SD card.
To work with all the JSON Files we keep two mapping files on the SD card. One mapping file contains every unique ID and its corresponding barcode.
The other mapping file contains every barcode and a list of corresponding unique IDs. The mapping files are also saved as JSON Files.
These two mappings enable us to quickly find the corresponding files when searching for a barcode and also contain an overview over all products in the inventory.

\section{Problems and Solutions}

\subsection{Arduino IDE Troubles}
When starting out on the project we produced our first few lines of code using Arduino IDE, however as the project became bigger we ran into several inconveniences.
Arduino IDE fundamentally puts everything into a single .ino file for the compilation. With additional .cpp files used for code structure there is an annoying limitation that it still requires a .ino file with the parent folder name being the same as the .ino file. \\
As we have a lot of hardware and an adafruit controller, we needed to install specific Adafruit library forks for the code to run. 
Since Arduino IDE doesn't offer collaborative library management, you had to make sure to have the correct libraries and library versions set up correctly on every single client. \\
When we finished work on a relevant module like the database class, Arduino IDE provided no testing framework for unittests which we could easily use to ensure correctness. \\
Lastly we also wanted to use external code editors instead of working with the Arduino IDE interface.
We did some research into alternatives and pleasantly found PlatformIO, an IDE for embedded software development.
It very much offered all we were looking for, we can define our platform, the specific microcontroller, and then list all required libraries and versions in a single central config file.
With the "Unity" test framework we also set up unit tests for our wifi and database functions.
Now running or testing the project just required to pull it from github and run it with platformio.
\subsection{Database}
When programming the database logic, which was supposed to hold the information about the inventory, we struggled with the RAM constrains of a microcontroller.
We looked into SQL but soon found that a SQL database on a microcontroller doesn't make sense as you run into processing power and RAM limitations.
We then settled for the JSON format which seemed like a solid way to store information and there was a Arduino JSON library available.
However we couldn't just store all products in a single inventory JSON file as eventually opening this file would fill up our available RAM.
So we came up with the idea to simply store single JSON files for each product and in additonal files store logical mappings so we are able to find the relevant files again.
Getting this to work correctly took a lot of unit testing as saving the files correctly on the SD card and editing the mappings with the Arduino JSON library was prone to errors.
\subsection{SD Card Library}
We initially used the standard \href{https://github.com/arduino-libraries/SD}{Arduino SD Library} for writing and reading files on the SD card. The bulk of our database logic was implemented using it.
It had annoying limitations like the filename not being allowed to be over 8 characters but that was acceptable.
However as we began to use folder structures for saving files we also found out that the library doesn't support deleting a folder containing other files, even though the documentation states that the folder deletion works recursively.
This was a problem, especially for testing, so we started looking for alternatives. We found that the SD library is in reality a simple wrapper for the more powerful \href{https://github.com/greiman/SdFat}{SD Fat} library, which offers more functions and less limitations.
And luckily we also found an \href{https://github.com/adafruit/SdFat}{SdFat Adafruit Fork} for our microcontroller. Fearing that with the new library we need to rewrite a lot of implementation, we switched to it.
To our surprise, we didn't need to change a single line of code in our database logic for it to work. It used the same class and function names as before, only now we had access to more useful functions like recursively deleting directories.
This was a funny exception to us, as so far, things generally didn't work when trying them out.
\section{Summary}

\section{Sources}



\bibliographystyle{apalike}
\bibliography{references}
\end{document}
